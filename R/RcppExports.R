# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

biliInter <- function(x, y, z, xout, yout) {
    .Call(`_jres_biliInter`, x, y, z, xout, yout)
}

reshape_submatToMat <- function(si_f2, si_f1, xdim_f2, xdim_f1, spec) {
    .Call(`_jres_reshape_submatToMat`, si_f2, si_f1, xdim_f2, xdim_f1, spec)
}

#' @title Perform matrix convolution
#' @param A Matrix A
#' @param B Matrix B
#' @return A convolved with B
convolve3cpp <- function(A, B) {
    .Call(`_jres_convolve3cpp`, A, B)
}

#' @title List all combinations of two vectors
#' @param x Vector A
#' @param y Vector B
#' @return all combinations, iterating first on B, then on A
expandGrid_rcpp <- function(x, y) {
    .Call(`_jres_expandGrid_rcpp`, x, y)
}

#' @title Symmetrise signal using f2 as mirror axis and using min values
#' @param A Matrix A 
#' @return summetrised A
matsymminf2f1 <- function(A, idx_cent_row, idx_cent_col) {
    .Call(`_jres_matsymminf2f1`, A, idx_cent_row, idx_cent_col)
}

matsymminf2 <- function(A, idx_cent) {
    .Call(`_jres_matsymminf2`, A, idx_cent)
}

#' @title Vector boundary finder when adding number to index 
#' @param i index of vector
#' @param add_int index count added / subtracted from i
#' @param mat_end length of the vector 
#' @param type addition or subtraction (specified by + or - symbol)
#' @return all combinations, iterating first on B, then on A
getBoundary <- function(i, add_int, mat_end, type = '-') {
    .Call(`_jres_getBoundary`, i, add_int, mat_end, type)
}

#' @title Summation of two matrices of the same dimensions
#' @param A Matrix A 
#' @param A Matrix B 
#' @return A + B
matsum <- function(A, B) {
    .Call(`_jres_matsum`, A, B)
}

#' @title Power transform each matrix element
#' @param Matrix A
#' @param exp power
#' @return A^exp
matpow <- function(A, exp) {
    .Call(`_jres_matpow`, A, exp)
}

#' @title Summation of all matrix elements to a double
#' @param Matrix A
#' @return sum(A)
matsumup <- function(A) {
    .Call(`_jres_matsumup`, A)
}

#' @title Min-max normalisation for matrix
#' @param Matrix A
#' @return min-max-scaled A (values range from 0-1)
minmaxMat <- function(A) {
    .Call(`_jres_minmaxMat`, A)
}

#' @title Find indices of points on axis that are closest after adding/subtracting a constant from a center point
#' @param ppm Axis/ scale vector
#' @param i index for ppm, determining point where constand should be added/subtracted
#' @param add Constand to be added/subtracted (on ppm scale)
#' @return indieces of ppm (lower, upper)
getBBdim_rcpp <- function(ppm, i, add) {
    .Call(`_jres_getBBdim_rcpp`, ppm, i, add)
}

#' @title Calculate Laplacian of Gaussians to determine peak size / bounding box dimension
#' @param sub Matrix with signal
#' @param f1hz Row scale of sub (Jres f1, expresed in Hz)
#' @param f2hz Col scale of sub (Jres f2, expressed in Hz)
#' @param cent_f1hz Location of peak maximum in f1 dimension
#' @param cent_f2hz Location of peak maximum in f2 dimension
#' @param sf Spectrometer frequency
#' @param npix SD parameter values used to create Gaussians - should span expected Jres signal fwhm range 
#' @return List, 1st element: Best matching Gaussian SD (peak size), 2nd element: Evaluation criterium for all tested SD
lapOfG <- function(sub, f1hz, f2hz, cent_f1hz, cent_f2hz, sf, npix, dbug) {
    .Call(`_jres_lapOfG`, sub, f1hz, f2hz, cent_f1hz, cent_f2hz, sf, npix, dbug)
}

#' @title Perform peak picking and get bounding box dimensions
#' @param jr Jres matrix, f1 in rows and f2 in cols
#' @param f1hz F1 scale of jr (Hz)
#' @param f2hz F2 scale of jr (ppm)
#' @param noise Intensity threshold for noise (no peaks are detected below this value)
#' @param boundary Initial bounding box estimate for determining peak size (one side estimate: x +/- boundary), this should be large enought to capture large signals (expressed in Hz)
#' @param sf Spectrometer frequency
#' @return List of dataframes summarising the detected peaks/features
pickPeaks_rcpp <- function(jr, f1hz, f2ppm, noise, boundary, sf, dbug) {
    .Call(`_jres_pickPeaks_rcpp`, jr, f1hz, f2ppm, noise, boundary, sf, dbug)
}

#' @title Generate 2D Gaussian distribution
#' @param x description of first dimensions (e.g. ppm values)
#' @param y description of second dimensions (e.g. Hz values)
#' @param mu distribution's center position using coordinate in x and y dimension
#' @param sigma distribution's spread (standard deviation) in x and y dimension
#' @return Numeric vector of coordinates
d2gauss_cpp <- function(x, y, mu, sigma) {
    .Call(`_jres_d2gauss_cpp`, x, y, mu, sigma)
}

#' @title Generate 2D Cauchy distribution
#' @param x description of first dimensions (e.g. ppm values)
#' @param y description of second dimensions (e.g. Hz values)
#' @param mu distribution's center position using coordinate in x and y dimension
#' @param sigma distribution's spread (standard deviation) in x and y dimension
#' @return Numeric vector of coordinates
d2cauchy_cpp <- function(x, y, mu, gamma) {
    .Call(`_jres_d2cauchy_cpp`, x, y, mu, gamma)
}

